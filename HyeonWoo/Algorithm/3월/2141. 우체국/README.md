# [Gold IV] 우체국 - 2141 

[문제 링크](https://www.acmicpc.net/problem/2141) 

### 성능 요약

메모리: 52412 KB, 시간: 644 ms

### 분류

그리디 알고리즘, 정렬

### 문제 설명

수직선과 같은 일직선상에 N개의 마을이 위치해 있다. i번째 마을은 X[i]에 위치해 있으며, A[i]명의 사람이 살고 있다.

이 마을들을 위해서 우체국을 하나 세우려고 하는데, 그 위치를 어느 곳으로 할지를 현재 고민 중이다. 고민 끝에 나라에서는 각 사람들까지의 거리의 합이 최소가 되는 위치에 우체국을 세우기로 결정하였다. 우체국을 세울 위치를 구하는 프로그램을 작성하시오.

각 마을까지의 거리의 합이 아니라, 각 사람까지의 거리의 합임에 유의한다

### 입력 

첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 X[1], A[1], X[2], A[2], …, X[N], A[N]이 주어진다. 범위는 |X[i]| ≤ 1,000,000,000, 1 ≤ A[i] ≤ 1,000,000,000 이며 모든 입력은 정수이다.

### 출력 

첫째 줄에 우체국의 위치를 출력한다. 가능한 경우가 여러 가지인 경우에는 더 작은 위치를 출력하도록 한다.

### 풀이

기본적으로 주어지는 값의 범위가 크기 때문에 long타입으로 선언하지 않으면 풀 수 없다.

풀이를 간단히 설명하자면 특정 위치에서 왼쪽의 인원수와 오른쪽의 인원수의 차이가 가장 적을 때를 구하는 것이다.

#### 풀이 순서
1. 마을 위치와 인원수를 이차원 리스트에 저장한다.
2. 해당 리스트를 마을 위치 기준으로 오름차순 정렬한다. -> 마을 위치가 주어질 대 오름차순이 아닐 경우를 대비하여
3. 첫번째 마을부터 순회하며 인원을 누적 합 해준다.
  3.1. { [1, 4], [2, 1], [3, 6] } -> { [1, 4], [2, 5], [3, 11] }
4. 양 끝을 포인터로 두어 이진 탐색을 진행한다.
5. 왼쪽 끝부터 mid 까지의 인원 수인 "ary[mid]", 오른쪽 끝부터 mid+1 까지의 인원 수인 "ary[n -1] - ary[mid]"를 비교한다.
  5.1. "ary[mid]" 인원 수가 더 많으면 최소값을 갱신하고 오른쪽 포인터를 mid - 1로 해준다.
  5.2. "ary[n -1] - ary[mid]" 인원 수가 더 많으면 왼쪽 포인터를 mid + 1로 해준다.
  5.3. 더 이상 탐색할 값이 없을 때 까지 반복한다.


#### 5.1. "ary[mid]"의 인원 수에서 우체국이 세워진 마을의 인원 수를 빼지 않는 이유
우체국을 세운 마을을 제외하고 왼쪽, 오른쪽의 인원을 비교해야 하지 않나 싶지만 풀이를 보면 "ary[mid]"의 인원 수는 우체국을 세우는 마을의 인원 수 까지 포함 한 것으로 보인다.

그 이유는 마을의 위치는 중복될 수 있다는 점이다.

예를 들자면 { [1, 3], [2, 4], [2, 5], [4, 6] } 와 같은 경우다.

해당 경우에서 3번째 마을의 인원을 빼준다고 해도 중복된 마을 위치가 또 있기 때문에 의미 없다.

중복된 경우가 아니어도 우체국이 세워진 마을의 인원수를 빼지 않는 이유는 간단한 예를 통해 직접 확인해 보자!

각 인덱스가 위치이고 원소는 인원수를 나타내는 다음과 같은 배열이 있을 때
{1, 2, 3, 4, 5} 
우체국이 위치한 마을의 인원 수를 빼는 경우와 아닌 경우를 확인해 보자.

당연하게 동작 방식에 차이가 없을 것이다.

결론적으로 우체국이 세워진 마을의 인원을 빼는 것은 중복인 경우가 있으니 어렵고, 빼지 않는건 상관 없으니 빼지 않고 이분 탐색을 하는 것이다.




