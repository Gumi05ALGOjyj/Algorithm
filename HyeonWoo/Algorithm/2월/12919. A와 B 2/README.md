# [Gold V] A와 B와 2 - 12919 

[문제 링크](https://www.acmicpc.net/problem/12919) 

### 성능 요약

메모리: 14220 KB, 시간: 100 ms

### 분류

- 구현
- 문자열
- 브루트포스 알고리즘
- 재귀

### 문제 설명

수빈이는 A와 B로만 이루어진 영어 단어 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.

이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.

- 문자열의 뒤에 A를 추가한다.
- 문자열의 뒤에 B를 추가하고 문자열을 뒤집는다.

주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오. 

### 입력 

첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 49, 2 ≤ T의 길이 ≤ 50, S의 길이 < T의 길이)

### 출력 

S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.

### 알고리즘 접근 방식
재귀 함수 호출을 통해 모든 경우를 확인하되 호출 할 때마다 조건을 확인하는 그리디 알고리즘을 적용하여 계산 시간을 줄인다.
 
### 풀이
고려해야하는 경우는 총 두가지 이다.

- 단순이 A를 뒤에 추가하는 경우
- B를 뒤에 추가함과 동시에 뒤집는 경우

이 두가지 경우를 모두 고려하여 재귀 함수 호출로 모든 경우를 확인하려 했다.

이때 B를 추가할 때마다 문자열을 뒤집는다면 많은 시간이 소요될 것 같아, reverse라는 boolean형 변수를 두어 상태를 관리했다.
- reverse가 true 일 때 : 문자열 앞에 A or B를 추가
- reverse가 false 일 때 : 문자열 뒤에 A or B를 추가

![SSAFY-13](https://user-images.githubusercontent.com/88186460/219870492-7047eec6-4810-424c-a692-03149137c9ff.jpg)

![SSAFY-14](https://user-images.githubusercontent.com/88186460/219870493-e117b2b1-8725-40ce-ab3d-a08ec63d67fe.jpg)

그리고 목적 문자열과 길이가 같아졌을 경우 문자열이 같은지 확인하면 된다.

하지만 이렇게만 풀면 시간초과가 난다.
시간을 줄이기 위해 애초에 안되는 경우를 사전에 알아내어 끝내야 한다.

다음과 같이 현재 문자열이 목적 문자열에 포함되지 않는다면 그 이후로 어떤 경우든 안되기 때문에 재귀를 끝낸다.

![SSAFY-15](https://user-images.githubusercontent.com/88186460/219870545-ef5bccab-3463-4256-8015-c285d5effe85.jpg)
