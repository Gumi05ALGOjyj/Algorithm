# [Gold II] 네트워크 복구 - 2211 

[문제 링크](https://www.acmicpc.net/problem/2211) 

### 성능 요약

메모리: 92792 KB, 시간: 544 ms

### 분류

그래프 이론, 데이크스트라

### 문제 설명

N(1 ≤ N ≤ 1,000)개의 컴퓨터로 구성된 네트워크가 있다. 이들 중 몇 개의 컴퓨터들은 서로 네트워크 연결이 되어 있어 서로 다른 두 컴퓨터 간 통신이 가능하도록 되어 있다. 통신을 할 때에는 서로 직접 연결되어 있는 회선을 이용할 수도 있으며, 회선과 다른 컴퓨터를 거쳐서 통신을 할 수도 있다.

각 컴퓨터들과 회선은 그 성능이 차이가 날 수 있다. 따라서 각각의 직접 연결되어 있는 회선을 이용해서 통신을 하는데 걸리는 시간이 서로 다를 수 있다. 심지어는 직접 연결되어 있는 회선이 오히려 더 느려서, 다른 컴퓨터를 통해서 통신을 하는 것이 더 유리할 수도 있다. 직접 연결되어 있는 회선을 사용할 경우에는 그 회선을 이용해서 통신을 하는 데 드는 시간만큼이 들게 된다. 여러 개의 회선을 거치는 경우에는 각 회선을 이용해서 통신을 하는 데 드는 시간의 합만큼의 시간이 걸리게 된다.

어느 날, 해커가 네트워크에 침입하였다. 네트워크의 관리자는 우선 모든 회선과 컴퓨터를 차단한 후, 해커의 공격을 막을 수 있었다. 관리자는 컴퓨터에 보안 시스템을 설치하려 하였는데, 버전 문제로 보안 시스템을 한 대의 슈퍼컴퓨터에만 설치할 수 있었다. 한 컴퓨터가 공격을 받게 되면, 네트워크를 통해 슈퍼컴퓨터에 이 사실이 전달이 되고, 그러면 슈퍼컴퓨터에서는 네트워크를 이용해서 보안 패킷을 전송하는 방식을 사용하기로 하였다. 준비를 마친 뒤, 관리자는 다시 네트워크를 복구하기로 하였다. 이때, 다음의 조건들이 만족되어야 한다.

1. 해커가 다시 공격을 할 우려가 있기 때문에, 최소 개수의 회선만을 복구해야 한다. 물론, 그렇다면 아무 회선도 복구하지 않으면 되겠지만, 이럴 경우 네트워크의 사용에 지장이 생기게 된다. 따라서 네트워크를 복구한 후에 서로 다른 두 컴퓨터 간에 통신이 가능하도록 복구해야 한다.
2. 네트워크를 복구해서 통신이 가능하도록 만드는 것도 중요하지만, 해커에게 공격을 받았을 때 보안 패킷을 전송하는 데 걸리는 시간도 중요한 문제가 된다. 따라서 슈퍼컴퓨터가 다른 컴퓨터들과 통신하는데 걸리는 최소 시간이, 원래의 네트워크에서 통신하는데 걸리는 최소 시간보다 커져서는 안 된다.

원래의 네트워크에 대한 정보가 주어졌을 때, 위의 조건을 만족하면서 네트워크를 복구하는 방법을 알아내는 프로그램을 작성하시오.

### 입력 

첫째 줄에 두 정수 N, M이 주어진다. 다음 M개의 줄에는 회선의 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 컴퓨터와 B번 컴퓨터가 통신 시간이 C (1 ≤ C ≤ 10)인 회선으로 연결되어 있다는 의미이다. 컴퓨터들의 번호는 1부터 N까지의 정수이며, 1번 컴퓨터는 보안 시스템을 설치할 슈퍼컴퓨터이다. 모든 통신은 완전쌍방향 방식으로 이루어지기 때문에, 한 회선으로 연결된 두 컴퓨터는 어느 방향으로도 통신할 수 있다.

### 출력 

첫째 줄에 복구할 회선의 개수 K를 출력한다. 다음 K개의 줄에는 복구한 회선을 나타내는 두 정수 A, B를 출력한다. 이는 A번 컴퓨터와 B번 컴퓨터를 연결하던 회선을 복구한다는 의미이다. 출력은 임의의 순서대로 하며, 답이 여러 개 존재하는 경우에는 아무 것이나 하나만 출력하면 된다.

### 문제 풀이

#### 고려 조건
1. 1번 컴퓨터 부터 시작한다.
2. 모든 컴퓨터가 연결되어야 한다.

#### 풀이 방법
고려 조건 1번은 1번 컴퓨터부터 bfs로 탐색을 시작하면 되고 여기서 2번의 조건도 bfs 탐색으로 경로를 찾는다면 모두 연결 될 거라는 의미 이므로 조건에 부합한다.

당연히 단순 bfs 탐색이 아니라 데이크스트라 알고리즘을 통해 최소 경로를 찾을 때마다 해당 경로를 저장하여 마지막에 결과와 함께 출력한다.

<br/>

먼저 1부터 시작한다. 1은 시작이므로 dlist도 0으로 초기화 하고 queue에 넣어준다.

이 때 큐는 dlist의 값을 기준으로 한 우선순위 큐이다.

![SSAFY-37](https://user-images.githubusercontent.com/88186460/224487401-f0e3d978-8f34-4f2a-99c4-48c196adfe11.jpg)

그 다음 1번 컴퓨터에 연결된 2, 3, 4 컴퓨터를 확인한다.

셋 모두 1번 컴퓨터의 dlist값을 더한 0 + 1, 0 + 2, 0 + 4의 값을 dlist에 저장하고 queue에 삽입한다.

이 때 dlist 값의 오름차순을 기준으로 하여 우선순위 큐에 정렬이 된다.

![SSAFY-38](https://user-images.githubusercontent.com/88186460/224487576-6832a175-ade6-41fd-8553-64de279f2406.jpg)

다음 queue에서 dlist값이 가장 작은 2번을 가져온다.

그리고 연결된 4번을 확인한다. 4번의 dlist 값 4보다 2의 dlist 값과 2 -> 4의 값을 더한 1 + 2 = 3이 더 작기 때문에 최신화 해준다.

1도 연결되어 있지만 1은 이미 0이기 때문에 더 낮은 값을 넣을 수 없다.

![SSAFY-39](https://user-images.githubusercontent.com/88186460/224487729-23d6829d-79a7-443f-9a24-61d215b9d5fb.jpg)

해당 과정을 더 이상 최신화 할 수 없을 때까지 반복한다.

이때 필요한 결과는 선의 수와 해당 경로의 정보(시작, 끝)이다.

선의 수는 무조건 전체 컴퓨터의 수(n)보다 1개 작은 수이다. 모두가 연결되어 있어야 한다는 조건에 부합하기 위해서 이다.

경로의 정보는 해당 컴퓨터의 dlist의 값이 수정(더 작은 값으로) 될 때마다 해당 경로를 저장해 주면 된다.

