# [Gold IV] 가장 가까운 공통 조상 - 3584 

[문제 링크](https://www.acmicpc.net/problem/3584) 

### 성능 요약

메모리: 22480 KB, 시간: 200 ms

### 분류

- 그래프 이론
- 그래프 탐색
- 트리
- 깊이 우선 탐색
- 최소 공통 조상

### 문제 설명

루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Anscestor)은 다음과 같이 정의됩니다.

- 두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.

![다운로드](https://user-images.githubusercontent.com/88186460/219870889-faa90b26-4993-4b1f-b252-650aa285d28f.png)

예를 들어  15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.

루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요

### 입력 

첫 줄에 테스트 케이스의 개수 T가 주어집니다.

각 테스트 케이스마다, 첫째 줄에 트리를 구성하는 노드의 수 N이 주어집니다. (2 ≤ N ≤ 10,000)

그리고 그 다음 N-1개의 줄에 트리를 구성하는 간선 정보가 주어집니다. 한 간선 당 한 줄에 두 개의 숫자 A B 가 순서대로 주어지는데, 이는 A가 B의 부모라는 뜻입니다. (당연히 정점이 N개인 트리는 항상 N-1개의 간선으로 이루어집니다!) A와 B는 1 이상 N 이하의 정수로 이름 붙여집니다.

테스트 케이스의 마지막 줄에 가장 가까운 공통 조상을 구할 두 노드가 주어집니다.

### 출력 

각 테스트 케이스 별로, 첫 줄에 입력에서 주어진 두 노드의 가장 가까운 공통 조상을 출력합니다.

### 알고리즘 접근 방식
알고리즘 접근이 아닌 단순 구현에 가깝다. 굳이 알고리즘을 찾자면 트리 탐색이다.
 
### 풀이
두개의 노드가 주어졌을 때 임의로 선택한 하나의 노드로부터 루트 노트까지 올라가며 방문 처리를 한다.

그 뒤 남은 노드도 루트 노드까지 올라가며 방문 확인을 한다.

이 때 가장 먼저 발견하는 방문한 노드가 가장 가까운 공통 조상 노드이다.

![SSAFY-16](https://user-images.githubusercontent.com/88186460/219871285-6fd132f2-9134-4214-8762-ec1b4c8cfc61.jpg)

![SSAFY-17](https://user-images.githubusercontent.com/88186460/219871286-b06ea675-94a4-4345-9544-625846ada5af.jpg)

![SSAFY-18](https://user-images.githubusercontent.com/88186460/219871287-1c76ca97-0446-4b70-a542-06617d2815b5.jpg)



