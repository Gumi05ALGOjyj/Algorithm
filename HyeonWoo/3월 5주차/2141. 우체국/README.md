# [Gold IV] 우체국 - 2141 

[문제 링크](https://www.acmicpc.net/problem/2141) 

### 성능 요약

메모리: 52412 KB, 시간: 644 ms

### 분류

그리디 알고리즘, 정렬

### 문제 설명

수직선과 같은 일직선상에 N개의 마을이 위치해 있다. i번째 마을은 X[i]에 위치해 있으며, A[i]명의 사람이 살고 있다.

이 마을들을 위해서 우체국을 하나 세우려고 하는데, 그 위치를 어느 곳으로 할지를 현재 고민 중이다. 고민 끝에 나라에서는 각 사람들까지의 거리의 합이 최소가 되는 위치에 우체국을 세우기로 결정하였다. 우체국을 세울 위치를 구하는 프로그램을 작성하시오.

각 마을까지의 거리의 합이 아니라, 각 사람까지의 거리의 합임에 유의한다

### 입력 

첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 X[1], A[1], X[2], A[2], …, X[N], A[N]이 주어진다. 범위는 |X[i]| ≤ 1,000,000,000, 1 ≤ A[i] ≤ 1,000,000,000 이며 모든 입력은 정수이다.

### 출력 

첫째 줄에 우체국의 위치를 출력한다. 가능한 경우가 여러 가지인 경우에는 더 작은 위치를 출력하도록 한다.

### 풀이

기본적으로 주어지는 값의 범위가 크기 때문에 long타입으로 선언하지 않으면 풀 수 없다.

풀이를 간단히 설명하자면 특정 위치에서 왼쪽의 인원수와 오른쪽의 인원수의 차이가 가장 적을 때를 구하는 것이다.

#### 풀이 순서
1. 마을 위치와 인원수를 이차원 리스트에 저장한다.
2. 해당 리스트를 마을 위치 기준으로 오름차순 정렬한다. -> 마을 위치가 주어질 대 오름차순이 아닐 경우를 대비하여
3. 첫번째 마을부터 순회하며 인원을 누적 합 해준다.
  3.1. { [1, 4], [2, 1], [3, 6] } -> { [1, 4], [2, 5], [3, 11] }
4. 양 끝을 포인터로 두어 이진 탐색을 진행한다.
5. 왼쪽 끝부터 mid 까지의 인원 수인 "ary[mid]", 오른쪽 끝부터 mid+1 까지의 인원 수인 "ary[n -1] - ary[mid]"를 비교한다.
  5.1. "ary[mid]" 인원 수가 더 많으면 최소값을 갱신하고 오른쪽 포인터를 mid - 1로 해준다.
  5.2. "ary[n -1] - ary[mid]" 인원 수가 더 많으면 왼쪽 포인터를 mid + 1로 해준다.
  5.3. 더 이상 탐색할 값이 없을 때 까지 반복한다.


#### 5.1. "ary[mid]"의 인원 수에서 우체국이 세워진 마을의 인원 수를 빼지 않는 이유
우체국을 세운 마을을 제외하고 왼쪽, 오른쪽의 인원을 비교해야 하지 않나 싶지만 풀이를 보면 "ary[mid]"의 인원 수는 우체국을 세우는 마을의 인원 수 까지 포함 한 것으로 보인다.

그 이유는 마을의 위치는 중복될 수 있다는 점이다.

예를 들자면 { [1, 3], [2, 4], [2, 5], [4, 6] } 와 같은 경우다.

해당 경우에서 3번째 마을의 인원을 빼준다고 해도 중복된 마을 위치가 또 있기 때문에 의미 없다.

중복된 경우가 아니어도 우체국이 세워진 마을의 인원수를 빼지 않는 이유는 같단한 예를 통해 직접 확인해 보자!

각 인덱스가 위치이고 원소는 인원수를 나타내는 다음과 같은 배열이 있을 때
{1, 2, 3, 4, 5} 
우체국이 위치한 마을의 인원 수를 빼는 경우와 아닌 경우를 확인해 보자
차이가 없을 것이다.




