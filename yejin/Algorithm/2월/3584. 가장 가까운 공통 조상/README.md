# [Gold IV] 가장 가까운 공통 조상 - 3584 

[문제 링크](https://www.acmicpc.net/problem/3584) 

### 성능 요약

메모리: 29212 KB, 시간: 236 ms

### 분류

깊이 우선 탐색(dfs), 그래프 이론(graphs), 그래프 탐색(graph_traversal), 최소 공통 조상(lca), 트리(trees)

### 문제 설명

<p>루트가 있는 트리(rooted tree)가 주어지고, 그 트리 상의 두 정점이 주어질 때 그들의 가장 가까운 공통 조상(Nearest Common Anscestor)은 다음과 같이 정의됩니다.</p>

<ul>
	<li>두 노드의 가장 가까운 공통 조상은, 두 노드를 모두 자손으로 가지면서 깊이가 가장 깊은(즉 두 노드에 가장 가까운) 노드를 말합니다.</li>
</ul>

<p style="text-align:center"><img alt="nca.png" src="https://upload.acmicpc.net/4f2eae58-31bf-445f-a7a3-625505e7102c/-/preview/" style="height:278px; width:304px"></p>

<p>예를 들어  15와 11를 모두 자손으로 갖는 노드는 4와 8이 있지만, 그 중 깊이가 가장 깊은(15와 11에 가장 가까운) 노드는 4 이므로 가장 가까운 공통 조상은 4가 됩니다.</p>

<p>루트가 있는 트리가 주어지고, 두 노드가 주어질 때 그 두 노드의 가장 가까운 공통 조상을 찾는 프로그램을 작성하세요</p>

### 입력 

 <p>첫 줄에 테스트 케이스의 개수 T가 주어집니다.</p>

<p>각 테스트 케이스마다, 첫째 줄에 트리를 구성하는 노드의 수 N이 주어집니다. (2 ≤ N ≤ 10,000)</p>

<p>그리고 그 다음 N-1개의 줄에 트리를 구성하는 간선 정보가 주어집니다. 한 간선 당 한 줄에 두 개의 숫자 A B 가 순서대로 주어지는데, 이는 A가 B의 부모라는 뜻입니다. (당연히 정점이 N개인 트리는 항상 N-1개의 간선으로 이루어집니다!) A와 B는 1 이상 N 이하의 정수로 이름 붙여집니다.</p>

<p>테스트 케이스의 마지막 줄에 가장 가까운 공통 조상을 구할 두 노드가 주어집니다.</p>

### 출력 

 <p>각 테스트 케이스 별로, 첫 줄에 입력에서 주어진 두 노드의 가장 가까운 공통 조상을 출력합니다.</p>


***

### 🖍️ 접근방법

#### 각 노드에서의 부모 노드를 포인터로 따라가서 공통 부모를 만난 경우에 노드의 숫자(이름)를 반환하도록 만들었다.
#### 첫번째 노드에서 부모 노드를 따라가는 경우에는 노드의 이름(숫자)을 리스트에 넣었다.
#### 두번째 노드에서 첫번째 노드에서 찾았던 부모 리스트에 중복된 노드가 존재하면 해당 노드의 이름(숫자)을 반환하도록 만들었다.

*** 

### 1️⃣ [입력예시1]
![image](https://user-images.githubusercontent.com/81174840/219211644-a874904d-71b7-437f-b61d-ef38fa6c6307.png)
![image](https://user-images.githubusercontent.com/81174840/219211709-ff95508d-a6d3-4eea-b7a1-d762f4622bef.png)

***

### 2️⃣ [입력예시2]
![image](https://user-images.githubusercontent.com/81174840/219211841-39b20c15-04f5-4045-a472-6ab4bb3f8bd2.png)





